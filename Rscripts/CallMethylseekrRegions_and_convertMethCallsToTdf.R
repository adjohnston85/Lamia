#!/usr/bin/env Rscript

#load all packages
library(optparse)
library(MethylSeekR)
library(data.table)
library(GenomicRanges)
library(rtracklayer)
library(BSgenome)
library(parallel)

#parse options & determine genome files
option_list = list(
  make_option(c("-g", "--genome"), type="character", default="hg38", 
              help="Mapped Genome, will be defined by you majel run", metavar="character"),
  make_option(c("-i", "--in_file"), type="character", default=NULL, 
              help="Input bedgraph file from Majel (generated by methyldackel)", metavar="character"),
  make_option(c("-t", "--tissue_map"), type="character", default=NULL, 
              help="location of csv file that maps tissue name to embryonic layer (will be set by Majel)", metavar="character"),
  make_option(c("-p", "--parallel"), type="numeric", default=, 
              help="Number of available cores for MethylSeekR - Defaults in Majel to 2*--aligner_threads (when aligner is bismark)", metavar="character")
); 

opt_parser = OptionParser(option_list=option_list);
opt = parse_args(opt_parser);

if(opt$genome == "hg38"){
  library(BSgenome.Hsapiens.UCSC.hg38)
}else if(opt$genome == "hg19"){
  library(BSgenome.Hsapiens.UCSC.hg19)
}

#set up colour map
bodyMap = read.csv(opt$tissue_map, header = TRUE, stringsAsFactors = FALSE)
colMap = list('Mesoderm' = as.matrix(c(231,138,195)),
              'Endoderm' = as.matrix(c(141,160,203)),
              'Ectoderm' = as.matrix(c(0,204,102)),
              'Stem' = as.matrix(c(205,92,92)),
              'Plasma' = as.matrix(c(255,215,0)),
              'Placenta' = as.matrix(c(205,92,92)),
              'Mesoderm_cancer' = as.matrix(c(190,113,160)),
              'Endoderm_cancer' = as.matrix(c(103,117,148)),
              'Ectoderm_cancer' = as.matrix(c(0,160,65)))
colMap = lapply(colMap, function(x){
  rownames(x) = c("red", "green", "blue")
  return(x)}
)

#methylseekR settings
FDR.cutoff <- 5
m.sel <- 0.5

#process the file
bGraph = opt$in_file
print(paste("Running", bGraph))
bGraph_name = gsub(".*/", "", bGraph)
out_prefix = gsub("_sd_CpG.bedGraph", "", bGraph_name)
#1st check the coverage, minimum needed is 10x
covFile = gsub("_CpG.bedGraph", "_coverage.txt", bGraph)
covDetails = read.delim(covFile, header = TRUE, stringsAsFactors = FALSE, row.names = 1)
if(covDetails$Average_Coverage < 10){
  print("Inadequate Coverage for methylseekR - making placeholder files")
  tmp_files = paste(out_prefix,
                    c("UMRLMR.bed",
                      "wPMD_UMRLMR.bed",
                      "PMD.bed"), sep = "_")
  sapply(tmp_files, function(x){
    write.table("MethylSeekR not run, coverage < 10x", x, 
                sep = "\t", row.names = FALSE, col.names = FALSE)
  })
  print("MethylSeekR Done")
}else{
  #load annotations
  print("Getting genome info")
  session <- browserSession()
  genome(session) <- opt$genome
  query <- ucscTableQuery(session, "cpgIslandExt")
  CpGislands.gr <- track(query)
  genome(CpGislands.gr) <- NA
  CpGislands.gr <- suppressWarnings(resize(CpGislands.gr, 5000, fix="center"))
  sLengths=seqlengths(Hsapiens)
  
  #methyldackel output is chr, start, end, % meth, M reads, U reads
  meth.df = fread(bGraph, data.table = FALSE, skip = 1)
  print("Making Meth GRanges")
  meth.gr = makeGRangesFromDataFrame(df = meth.df, 
                                     seqnames.field = "V1", 
                                     start.field = "V2", 
                                     end.field = "V3", 
                                     starts.in.df.are.0based = TRUE)
  #methylSeekR needs chr, start, end, Total Reads, M reads 
  meth.gr$'T' = rowSums(meth.df[,5:6], na.rm = TRUE)
  meth.gr$M = meth.df[,5]
  meth.gr = meth.gr[which(seqnames(meth.gr) %in% as.character(unique(seqnames(meth.gr))[unique(seqnames(meth.gr)) %in% names(sLengths)]))]
  #plot and call PMDs
  print("Calling PMDs")
  PMDsegments.gr <- segmentPMDs(m=meth.gr, chr.sel="chr22",
                                seqLengths=sLengths, num.cores=opt$parallel,
                                pdfFilename = paste(out_prefix, "_PMD_segmentation.pdf", sep = ""))
  pdf(paste(out_prefix, "_AlphaDistribution.pdf", sep = ""))
  plotAlphaDistributionOneChr(m=meth.gr, chr.sel="chr22",
                              num.cores=opt$parallel)
  plotAlphaDistributionOneChr(m=subsetByOverlaps(meth.gr,
                                                 PMDsegments.gr[values(PMDsegments.gr)$type=="notPMD"]), chr.sel="chr22",
                              num.cores=opt$parallel)
  dev.off()
  tmp_pmd = PMDsegments.gr
  mcols(tmp_pmd) =  NULL
  tmp_pmd$type = mcols(PMDsegments.gr)$type
  tmp_pmd = tmp_pmd[which(mcols(tmp_pmd)$type == "PMD")]
  plotPMDSegmentation(m=meth.gr, 
                      segs=PMDsegments.gr, 
                      numRegions = ifelse(length(PMDsegments.gr) >= 20, 20, length(PMDsegments.gr)),
                      pdfFilename = paste(out_prefix, "_PMDplots.pdf", sep = ""))
  #exports bed with seqnames, start, end,width, type, nCG
  print("Writing PMD bed file")
  write.table(as.data.frame(tmp_pmd)[,c(1:3,6)],
              file = paste(out_prefix, "_PMD.bed", sep = ""), 
              quote = FALSE, row.names = FALSE, col.names = FALSE,
              sep = "\t")
  #setup to call UMR/LMR
  print("Calculating cutoffs with PMDs")
  stats <- calculateFDRs(m=meth.gr, CGIs=CpGislands.gr,
                         PMDs=PMDsegments.gr, num.cores=opt$parallel,
                         pdfFilename = paste(out_prefix, "_wPMD_CalculateFDRs.pdf", sep = ""))
  n.sel=as.integer(names(stats$FDRs[as.character(m.sel), ]
                         [stats$FDRs[as.character(m.sel), ]<FDR.cutoff])[1])
  #UMR/LMR segmentation
  print("Calling UMR/LMR with PMDs")
  UMRLMRsegments_wPMD.gr <- segmentUMRsLMRs(m=meth.gr, meth.cutoff=m.sel,
                                            nCpG.cutoff=n.sel, PMDs=PMDsegments.gr,
                                            num.cores=opt$parallel, myGenomeSeq=Hsapiens,
                                            seqLengths=sLengths,
                                            pdfFilename = paste(out_prefix, "_wPMD_UMRsegmentation.pdf", sep = ""))
  plotFinalSegmentation(m=meth.gr, segs=UMRLMRsegments_wPMD.gr,
                        PMDs=PMDsegments.gr,meth.cutoff=m.sel,
                        numRegions = 20, 
                        pdfFilename =paste(out_prefix, "_wPMD_FinalSegmentationPlots.pdf", sep = ""))
  tmp_wPMD = UMRLMRsegments_wPMD.gr 
  mcols(tmp_wPMD) = NULL
  tmp_wPMD$type = mcols(UMRLMRsegments_wPMD.gr)$type
  #make bed
  print("Writing UMR/LMR bed with PMDs")
  write.table(as.data.frame(tmp_wPMD)[,c(1:3,6)],
              file = paste(out_prefix, "_wPMD_UMRLMR.bed", sep = ""), 
              quote = FALSE, row.names = FALSE, col.names = FALSE,
              sep = "\t")
  rm(list = c("stats", "n.sel"))
  gc()
  #now do it without PMDs
  #setup to call UMR/LMR
  print("Calculating Cutoffs w/o PMDs")
  stats <- calculateFDRs(m=meth.gr, CGIs=CpGislands.gr,
                         num.cores=opt$parallel,
                         pdfFilename = paste(out_prefix, "_CalculateFDRs.pdf", sep = ""))
  n.sel=as.integer(names(stats$FDRs[as.character(m.sel), ]
                         [stats$FDRs[as.character(m.sel), ]<FDR.cutoff])[1])
  #UMR/LMR segmentation
  print("UMR/LMR segmentation")
  UMRLMRsegments.gr <- segmentUMRsLMRs(m=meth.gr, meth.cutoff=m.sel,
                                       nCpG.cutoff=n.sel, 
                                       num.cores=opt$parallel, myGenomeSeq=Hsapiens,
                                       seqLengths=sLengths,
                                       pdfFilename = paste(out_prefix, "_UMRsegmentation.pdf", sep = ""))
  plotFinalSegmentation(m=meth.gr, segs=UMRLMRsegments.gr,
                        meth.cutoff=m.sel,
                        numRegions = 20, 
                        pdfFilename =paste(out_prefix, "_FinalSegmentationPlots.pdf", sep = ""))
  tmp = UMRLMRsegments.gr 
  mcols(tmp) = NULL
  tmp$type = mcols(UMRLMRsegments.gr)$type
  #make bed
  print("Writing output w/o PMDs")
  write.table(as.data.frame(tmp)[,c(1:3,6)],
              file = paste(out_prefix, "_UMRLMR.bed", sep = ""), 
              quote = FALSE, row.names = FALSE, col.names = FALSE,
              sep = "\t")
  print("Cleaning up")
  rm(list = c("UMRLMRsegments.gr", "n.sel", 
              "stats", "UMRLMRsegments_wPMD.gr", 
              "tmp", "tmp_pmd",
              "covDetails"))
  gc()
  print("MethylSeekR Done")
}

#now to do the tdf
tdf_file = gsub("bedGraph$", "tdf", bGraph_name)
#check if we skipped reading in meth data
if(!"meth.df" %in% ls()){
  meth.df = fread(bGraph, data.table = FALSE, skip = 1)
}
print("Remaking Meth GRanges for browsertrack")
meth.gr = makeGRangesFromDataFrame(df = meth.df, 
                                   seqnames.field = "V1", 
                                   start.field = "V2", 
                                   end.field = "V3", 
                                   starts.in.df.are.0based = TRUE)
meth.gr$score = meth.df$V4
#now make trackline
if(grepl("NeuN", bGraph)){
  sample_data = strsplit(gsub(".*\\/|_sd.*", "", bGraph), "_")[[1]]
  if(any(grepl("NeuNneg", sample_data))){
    NeuNstat = gsub("NeuNneg.*", "NueNnegative", sample_data[grep("NeuN", sample_data)])
  }else{
    NeuNstat = gsub("NeuNnpos.*", "NueNpostive", sample_data[grep("NeuN", sample_data)])
  }
  sample_data[2] = paste(sample_data[2], NeuNstat, sep = "")
}else{
  sample_data = strsplit(gsub(".*\\/|_sd.*", "", bGraph), "_")[[1]]
}
print("Create trackline")
tline = new("TrackLine")
tline@name=gsub(".*\\/|_sd.*", "", bGraph)
tline@description=paste(sample_data[1], sample_data[2], sep = "_")
if(tolower(sample_data[1]) == "skin"){
  germ_layer = unique(bodyMap[grep(tolower(sample_data[1]), bodyMap$tissue, ignore.case = TRUE),
                              "germ_layer"])
}else if(sample_data[1] == "CellLine"){
  germ_layer = unique(bodyMap[grep(tolower(sample_data[2]), bodyMap$tissue, ignore.case = TRUE),
                              "germ_layer"])
}else{
  germ_layer = unique(bodyMap[grep(gsub("Gland|Lobe","",sample_data[1]), bodyMap$simple_tissue, ignore.case = TRUE),
                              "germ_layer"])
}
#fix the occasional issue with grep returning more than one germ_layer
if(length(germ_layer) > 1) germ_layer = germ_layer[length(germ_layer)]
#convert colours for cancer, fetal or stem cell derived samples
if(any(grepl("CML|CLL|ALL|cancer|carcinoma|adenoma|blastoma|Neoplasm|Tumor|Oncocytoma|immortal|glioma", sample_data, ignore.case = TRUE))){
  germ_layer = paste(germ_layer, "cancer", sep = "_")
}else if(any(grepl("iPSC|fetal|ESC|Multipotent|H1Derived", sample_data, ignore.case = TRUE))){
  germ_layer = "Stem"
}
col = colMap[[intersect(names(colMap), germ_layer)]]
tline@color=as.integer(col)
print(tline)
#now to create the file
print("remove lambda and sort")
print("...")
meth.gr = meth.gr[seqnames(meth.gr) != 'lambda']
print("...")
meth.gr = sort(meth.gr)
print("done")
print("Create tmp file")
export.bedGraph(meth.gr, "tmp.bedGraph", trackLine=tline)
print("done")
print("Make TDF")
cmd = paste("igvtools toTDF tmp.bedGraph", tdf_file, opt$genome)
system(cmd)
print("Tidy Up")
file.remove("tmp.bedGraph")
